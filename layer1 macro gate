"""
DISCLAIMER:
This code is provided for educational and research purposes only.
It does not constitute financial advice, investment advice,
trading advice, or a recommendation to buy or sell any security.

Agora Lycos Trading Lab makes no guarantees regarding accuracy,
performance, or profitability. Use at your own risk.
Past performance is not indicative of future results.
"""


# layer1_macro_gate.py
from __future__ import annotations

import math
from dataclasses import dataclass
from datetime import date
from typing import Dict, Tuple

import numpy as np
import pandas as pd

try:
    import yfinance as yf
except ImportError:
    raise SystemExit("Install: pip install yfinance")

# --- Tickers (Layer 1 basket) ---
# You can also import ETF_TICKERS from your helper file if you want the full list:
# from filterstemplate import ETF_TICKERS  # :contentReference[oaicite:1]{index=1}
TICKERS = {
    "SPY": "Equities",
    "TLT": "Rates",
    "HYG": "Credit",
    "UUP": "USD",
    "USO": "Oil",
    "^VIX": "Vol",
}

# --- Utility math ---
def ema(series: pd.Series, span: int) -> pd.Series:
    return series.ewm(span=span, adjust=False).mean()

def zscore(series: pd.Series, lookback: int = 252) -> pd.Series:
    # rolling z-score; stable and fast
    mu = series.rolling(lookback, min_periods=max(20, lookback // 5)).mean()
    sd = series.rolling(lookback, min_periods=max(20, lookback // 5)).std(ddof=0)
    return (series - mu) / (sd.replace(0, np.nan))

def to_unit_interval(x: float) -> float:
    # logistic squashing; maps real -> (0,1)
    if x is None or (isinstance(x, float) and (math.isnan(x) or math.isinf(x))):
        return 0.5
    return 1.0 / (1.0 + math.exp(-x))

@dataclass
class MacroGateResult:
    asof: str
    regime: str
    confidence: float
    risk_on_score: float
    raw: pd.Series
    components_01: pd.Series

def fetch_closes(tickers: list[str], period: str = "2y") -> pd.DataFrame:
    df = yf.download(tickers, period=period, auto_adjust=True, progress=False)["Close"]
    if isinstance(df, pd.Series):
        df = df.to_frame()
    df = df.dropna(how="all")
    return df

def compute_macro_gate(closes: pd.DataFrame) -> MacroGateResult:
    px = closes.sort_index().ffill().dropna()

    spy = px["SPY"]
    vix = px["^VIX"]
    hyg = px["HYG"]
    tlt = px["TLT"]
    uup = px["UUP"]
    uso = px["USO"]

    # --- Existing raw z signals ---
    spy_trend = zscore(ema(spy, 20) / ema(spy, 200) - 1.0).iloc[-1]
    vix_level = zscore(vix).iloc[-1]
    vix_trend = zscore(vix.pct_change(5)).iloc[-1]

    credit_ratio = hyg / tlt
    credit_trend = zscore(ema(credit_ratio, 20) / ema(credit_ratio, 200) - 1.0).iloc[-1]

    usd_trend = zscore(ema(uup, 20) / ema(uup, 200) - 1.0).iloc[-1]
    oil_shock = zscore(uso.pct_change(5)).iloc[-1]

    # --- NEW: Rates risk (duration trend) ---
    tlt_trend = zscore(ema(tlt, 20) / ema(tlt, 200) - 1.0).iloc[-1]

    # --- NEW (recommended): Equity vs rates relative trend ---
    eq_vs_rates = spy / tlt
    eq_vs_rates_trend = zscore(ema(eq_vs_rates, 20) / ema(eq_vs_rates, 200) - 1.0).iloc[-1]

    raw = pd.Series(
        {
            "spy_trend_z": float(spy_trend),
            "vix_level_z": float(vix_level),
            "vix_trend_z": float(vix_trend),
            "credit_trend_z": float(credit_trend),
            "usd_trend_z": float(usd_trend),
            "oil_shock_z": float(oil_shock),
            # NEW
            "tlt_trend_z": float(tlt_trend),
            "eq_vs_rates_trend_z": float(eq_vs_rates_trend),
        }
    )

    components = pd.Series(
        {
            "spy": to_unit_interval(raw["spy_trend_z"]),
            "vix_level": to_unit_interval(-raw["vix_level_z"]),
            "vix_trend": to_unit_interval(-raw["vix_trend_z"]),
            "credit": to_unit_interval(raw["credit_trend_z"]),
            "usd": to_unit_interval(-raw["usd_trend_z"]),
            "oil": to_unit_interval(-abs(raw["oil_shock_z"])),
            # NEW
            "rates": to_unit_interval(raw["tlt_trend_z"]),
            "eq_vs_rates": to_unit_interval(raw["eq_vs_rates_trend_z"]),
        }
    )

    risk_on_score = float(components.mean())
    confidence = float(abs(risk_on_score - 0.5) * 2.0)

    if risk_on_score > 0.60:
        regime = "Risk-On"
    elif risk_on_score < 0.40:
        regime = "Risk-Off"
    else:
        regime = "Transition"

    asof = px.index[-1].date().isoformat()
    return MacroGateResult(
        asof=asof,
        regime=regime,
        confidence=confidence,
        risk_on_score=risk_on_score,
        raw=raw,
        components_01=components,
    )

def print_report(res: MacroGateResult) -> None:
    print("\n=== AGORA LYCOS â€” LAYER 1: MACRO REGIME GATE (KESTREL-R0) ===")
    print(f"As of:       {res.asof}")
    print(f"Regime:      {res.regime}")
    print(f"Confidence:  {res.confidence:.3f}")
    print(f"Risk score:  {res.risk_on_score:.3f}")

    print("\n--- Diagnostics (raw z-score signals) ---")
    print(res.raw.to_frame("value"))

    print("\n--- Diagnostics (component scores 0..1) ---")
    print(res.components_01.to_frame("value"))
    print()

def main():
    closes = fetch_closes(list(TICKERS.keys()), period="2y")
    res = compute_macro_gate(closes)
    print_report(res)

if __name__ == "__main__":
    main()
